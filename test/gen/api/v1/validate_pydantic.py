# DO NOT EDIT. Generated by protoc-gen-pydantic.

from typing import Annotated as _Annotated, Literal as _Literal

from pydantic import (
    AfterValidator as _AfterValidator,
    BaseModel as _BaseModel,
    ConfigDict as _ConfigDict,
    Field as _Field,
)

from ._proto_types import (
    ProtoDuration,
    ProtoInt64,
    ProtoTimestamp,
    ProtoUInt64,
    _make_const_validator,
    _make_in_validator,
    _make_not_in_validator,
    _require_finite,
    _require_unique,
    _validate_email,
    _validate_ip,
    _validate_ipv4,
    _validate_ipv6,
    _validate_uri,
    _validate_uuid,
)


class _ProtoModel(_BaseModel):
    """Base class for generated Pydantic models with ProtoJSON helpers."""

    def to_proto_dict(self, **kwargs) -> dict:
        """Serialize to a dict using ProtoJSON conventions.

        Omits fields with default (zero) values and uses original proto
        field names (camelCase aliases).
        """
        kwargs.setdefault("exclude_defaults", True)
        kwargs.setdefault("by_alias", True)
        return super().model_dump(**kwargs)

    def to_proto_json(self, **kwargs) -> str:
        """Serialize to a JSON string using ProtoJSON conventions.

        Omits fields with default (zero) values and uses original proto
        field names (camelCase aliases).
        """
        kwargs.setdefault("exclude_defaults", True)
        kwargs.setdefault("by_alias", True)
        return super().model_dump_json(**kwargs)

    @classmethod
    def from_proto_dict(cls, data: dict, **kwargs):
        """Deserialize from a dict using ProtoJSON conventions."""
        return cls.model_validate(data, **kwargs)

    @classmethod
    def from_proto_json(cls, json_str: str, **kwargs):
        """Deserialize from a JSON string using ProtoJSON conventions."""
        return cls.model_validate_json(json_str, **kwargs)


class ValidatedScalars(_ProtoModel):
    """
    ValidatedScalars exercises numeric bound constraints.

    Attributes:
      age (int):
        Age must be between 0 and 150 exclusive of 0.
      score (float):
        Score must be in [0.0, 100.0].
      priority (ProtoInt64):
        Priority must be positive.
      ratio (float):
        Ratio must be non-negative and less than 1.
      rank (int):
        Rank must be in [1, 10].
      count (ProtoUInt64 | None):
        Count must be non-zero (covers uint64 / fixed64 literal formatting).
      offset (int | None):
        Offset must be non-negative (covers sint32 / sfixed32 literal formatting).
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # Age must be between 0 and 150 exclusive of 0.
    age: "int" = _Field(
        default=0,
        description="Age must be between 0 and 150 exclusive of 0.",
        gt=0,
        le=150,
    )

    # Score must be in [0.0, 100.0].
    score: "float" = _Field(
        default=0.0,
        description="Score must be in [0.0, 100.0].",
        ge=0.0,
        le=100.0,
    )

    # Priority must be positive.
    priority: "ProtoInt64" = _Field(
        default=0,
        description="Priority must be positive.",
        gt=0,
    )

    # Ratio must be non-negative and less than 1.
    ratio: "float" = _Field(
        default=0.0,
        description="Ratio must be non-negative and less than 1.",
        ge=0.0,
        lt=1.0,
    )

    # Rank must be in [1, 10].
    rank: "int" = _Field(
        default=0,
        description="Rank must be in [1, 10].",
        ge=1,
        le=10,
    )

    # Count must be non-zero (covers uint64 / fixed64 literal formatting).
    count: "ProtoUInt64 | None" = _Field(
        default=None,
        description="Count must be non-zero (covers uint64 / fixed64 literal formatting).",
        gt=0,
    )

    # Offset must be non-negative (covers sint32 / sfixed32 literal formatting).
    offset: "int | None" = _Field(
        default=None,
        description="Offset must be non-negative (covers sint32 / sfixed32 literal formatting).",
        ge=0,
    )


class ValidatedStrings(_ProtoModel):
    """
    ValidatedStrings exercises string length and pattern constraints.

    Attributes:
      name (str):
        Name must be between 1 and 100 characters.
      code (str):
        Code must match uppercase letters only.
      bio (str):
        Bio has only a max length.
      tag (str):
        Tag has only a min length.
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # Name must be between 1 and 100 characters.
    name: "str" = _Field(
        default="",
        description="Name must be between 1 and 100 characters.",
        min_length=1,
        max_length=100,
    )

    # Code must match uppercase letters only.
    code: "str" = _Field(
        default="",
        description="Code must match uppercase letters only.",
        pattern="^[A-Z]+$",
    )

    # Bio has only a max length.
    bio: "str" = _Field(
        default="",
        description="Bio has only a max length.",
        max_length=500,
    )

    # Tag has only a min length.
    tag: "str" = _Field(
        default="",
        description="Tag has only a min length.",
        min_length=2,
    )


class ValidatedRepeated(_ProtoModel):
    """
    ValidatedRepeated exercises repeated field length constraints.

    Attributes:
      items (list[str]):
        Items must have between 1 and 10 elements.
      tags (list[str]):
        Tags must have at least 1 element.
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # Items must have between 1 and 10 elements.
    items: "list[str]" = _Field(
        default_factory=list,
        description="Items must have between 1 and 10 elements.",
        min_length=1,
        max_length=10,
    )

    # Tags must have at least 1 element.
    tags: "list[str]" = _Field(
        default_factory=list,
        description="Tags must have at least 1 element.",
        min_length=1,
    )


class ValidatedMap(_ProtoModel):
    """
    ValidatedMap exercises map field length constraints.

    Attributes:
      labels (dict[str, str]):
        Labels must have between 1 and 10 entries.
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # Labels must have between 1 and 10 entries.
    labels: "dict[str, str]" = _Field(
        default_factory=dict,
        description="Labels must have between 1 and 10 entries.",
        min_length=1,
        max_length=10,
    )


class ValidatedReserved(_ProtoModel):
    """
    ValidatedReserved exercises a field whose name is a Python reserved word and
    also carries a buf.validate constraint. The generated field must emit both
    alias= and the constraint kwargs in a single _Field() call.

    Attributes:
      float_ (float):
        Score must be positive.
    """

    model_config = _ConfigDict(
        populate_by_name=True,
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # Score must be positive.
    float_: "float" = _Field(
        default=0.0,
        description="Score must be positive.",
        alias="float",
        gt=0.0,
    )


class ValidatedOneof(_ProtoModel):
    """
    ValidatedOneof exercises a oneof field that also carries a constraint.

    Attributes:
      small (int | None):
        Must be positive when set.
      large (ProtoInt64 | None):
        Must be positive when set.
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # Must be positive when set.
    small: "int | None" = _Field(
        default=None,
        description="Must be positive when set.\nOnly one of the fields can be specified with: [small large] (oneof value)",
        gt=0,
    )

    # Must be positive when set.
    large: "ProtoInt64 | None" = _Field(
        default=None,
        description="Must be positive when set.\nOnly one of the fields can be specified with: [small large] (oneof value)",
        gt=0,
    )


class ValidatedDuration(_ProtoModel):
    """
    ValidatedDuration exercises Duration bound constraints, which use
    message-typed rule fields and cannot be translated to Pydantic Field() args.
    The generator must not panic; instead it emits dropped-constraint comments.

    Attributes:
      timeout (ProtoDuration | None):
        Timeout must be positive and at most one hour.
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # Timeout must be positive and at most one hour.
    timeout: "ProtoDuration | None" = _Field(
        default=None,
        description="Timeout must be positive and at most one hour.",
        # buf.validate: gt (not translated)
        # buf.validate: lte (not translated)
    )


class ValidatedTimestamp(_ProtoModel):
    """
    ValidatedTimestamp exercises Timestamp bound constraints, which also use
    message-typed rule fields and must not panic.

    Attributes:
      created_at (ProtoTimestamp | None):
        CreatedAt must be after the Unix epoch.
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # CreatedAt must be after the Unix epoch.
    created_at: "ProtoTimestamp | None" = _Field(
        default=None,
        description="CreatedAt must be after the Unix epoch.",
        # buf.validate: gt (not translated)
    )


class ValidatedStringLen(_ProtoModel):
    """
    ValidatedStringLen exercises the string.len exact-length constraint.

    Attributes:
      code (str):
        Code must be exactly 5 characters.
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # Code must be exactly 5 characters.
    code: "str" = _Field(
        default="",
        description="Code must be exactly 5 characters.",
        min_length=5,
        max_length=5,
    )


class ValidatedStringAffix(_ProtoModel):
    """
    ValidatedStringAffix exercises string.prefix and string.suffix constraints.

    Attributes:
      url (str):
        Url must start with "https://".
      filename (str):
        Filename must end with ".go".
      path (str):
        Path must start with "/home/" and end with ".txt".
      content (str):
        Content must match a pattern; prefix is also set (conflict → prefix dropped).
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # Url must start with "https://".
    url: "str" = _Field(
        default="",
        description='Url must start with "https://".',
        pattern="^https://",
    )

    # Filename must end with ".go".
    filename: "str" = _Field(
        default="",
        description='Filename must end with ".go".',
        pattern="\\.go$",
    )

    # Path must start with "/home/" and end with ".txt".
    path: "str" = _Field(
        default="",
        description='Path must start with "/home/" and end with ".txt".',
        pattern="^/home/.*\\.txt$",
    )

    # Content must match a pattern; prefix is also set (conflict → prefix dropped).
    content: "str" = _Field(
        default="",
        description="Content must match a pattern; prefix is also set (conflict → prefix dropped).",
        pattern="^[a-z]+$",
        # buf.validate: prefix (not translated)
    )


class ValidatedExamples(_ProtoModel):
    """
    ValidatedExamples exercises the field examples annotation.

    Attributes:
      count (int):
        Count with integer examples.
      name (str):
        Name with string examples.
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # Count with integer examples.
    count: "int" = _Field(
        default=0,
        description="Count with integer examples.",
        gt=0,
        examples=[1, 42],
    )

    # Name with string examples.
    name: "str" = _Field(
        default="",
        description="Name with string examples.",
        min_length=1,
        examples=["alice", "bob"],
    )


class ValidatedFormats(_ProtoModel):
    """
    ValidatedFormats exercises format and semantic validators: email, URI,
    IP address (v4/v6), UUID, and float finite.

    Attributes:
      email (_Annotated[str, _AfterValidator(_validate_email)]):
        Email must be a valid email address.
      website (_Annotated[str, _AfterValidator(_validate_uri)]):
        Website must be a valid URI.
      address (_Annotated[str, _AfterValidator(_validate_ip)]):
        Address must be a valid IP address.
      ratio (_Annotated[float, _AfterValidator(_require_finite)]):
        Ratio must be finite (not inf or NaN).
      token (_Annotated[str, _AfterValidator(_validate_uuid)]):
        Token must be a valid UUID.
      host_v4 (_Annotated[str, _AfterValidator(_validate_ipv4)]):
        Host must be a valid IPv4 address.
      host_v6 (_Annotated[str, _AfterValidator(_validate_ipv6)]):
        Host must be a valid IPv6 address.
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # Email must be a valid email address.
    email: "_Annotated[str, _AfterValidator(_validate_email)]" = _Field(
        default="",
        description="Email must be a valid email address.",
    )

    # Website must be a valid URI.
    website: "_Annotated[str, _AfterValidator(_validate_uri)]" = _Field(
        default="",
        description="Website must be a valid URI.",
    )

    # Address must be a valid IP address.
    address: "_Annotated[str, _AfterValidator(_validate_ip)]" = _Field(
        default="",
        description="Address must be a valid IP address.",
    )

    # Ratio must be finite (not inf or NaN).
    ratio: "_Annotated[float, _AfterValidator(_require_finite)]" = _Field(
        default=0.0,
        description="Ratio must be finite (not inf or NaN).",
    )

    # Token must be a valid UUID.
    token: "_Annotated[str, _AfterValidator(_validate_uuid)]" = _Field(
        default="",
        description="Token must be a valid UUID.",
    )

    # Host must be a valid IPv4 address.
    host_v4: "_Annotated[str, _AfterValidator(_validate_ipv4)]" = _Field(
        default="",
        description="Host must be a valid IPv4 address.",
    )

    # Host must be a valid IPv6 address.
    host_v6: "_Annotated[str, _AfterValidator(_validate_ipv6)]" = _Field(
        default="",
        description="Host must be a valid IPv6 address.",
    )


class ValidatedDropped(_ProtoModel):
    """
    ValidatedDropped exercises constraints that are recognised but not translated.

    Attributes:
      name (str):
        Name is required; the required constraint is not translated.
      blob (bytes):
        Blob has a bytes.const constraint which is not translated (bytes kind unsupported).
      score (int):
        Score must be positive; required is also set but not translated.
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # Name is required; the required constraint is not translated.
    name: "str" = _Field(
        default="",
        description="Name is required; the required constraint is not translated.",
        # buf.validate: required (not translated)
    )

    # Blob has a bytes.const constraint which is not translated (bytes kind unsupported).
    blob: "bytes" = _Field(
        default=b"",
        description="Blob has a bytes.const constraint which is not translated (bytes kind unsupported).",
        # buf.validate: const (not translated)
    )

    # Score must be positive; required is also set but not translated.
    score: "int" = _Field(
        default=0,
        description="Score must be positive; required is also set but not translated.",
        gt=0,
        # buf.validate: required (not translated)
    )


class ValidatedConst(_ProtoModel):
    """
    ValidatedConst exercises the const constraint translated to Literal[...].

    Attributes:
      tag (_Literal['fixed']):
      count (_Literal[42]):
      active (_Literal[True]):
      score (_Annotated[float, _AfterValidator(_make_const_validator(3.14))]):
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    tag: "_Literal['fixed']" = _Field(
        default="fixed",
    )

    count: "_Literal[42]" = _Field(
        default=42,
    )

    active: "_Literal[True]" = _Field(
        default=True,
    )

    score: "_Annotated[float, _AfterValidator(_make_const_validator(3.14))]" = _Field(
        default=3.14,
    )


class ValidatedIn(_ProtoModel):
    """
    ValidatedIn exercises in and not_in constraints translated to AfterValidator.

    Attributes:
      status (_Annotated[str, _AfterValidator(_make_in_validator(frozenset({'active', 'inactive'})))]):
      code (_Annotated[str, _AfterValidator(_make_not_in_validator(frozenset({'deleted', 'archived'})))]):
      priority (_Annotated[int, _AfterValidator(_make_in_validator(frozenset({1, 2, 3})))]):
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    status: "_Annotated[str, _AfterValidator(_make_in_validator(frozenset({'active', 'inactive'})))]" = _Field(
        default="",
    )

    code: "_Annotated[str, _AfterValidator(_make_not_in_validator(frozenset({'deleted', 'archived'})))]" = _Field(
        default="",
    )

    priority: "_Annotated[int, _AfterValidator(_make_in_validator(frozenset({1, 2, 3})))]" = _Field(
        default=0,
    )


class ValidatedUnique(_ProtoModel):
    """
    ValidatedUnique exercises repeated.unique translated to AfterValidator.

    Attributes:
      tags (_Annotated[list[str], _AfterValidator(_require_unique)]):
      scores (_Annotated[list[int], _AfterValidator(_require_unique)]):
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    tags: "_Annotated[list[str], _AfterValidator(_require_unique)]" = _Field(
        default_factory=list,
    )

    scores: "_Annotated[list[int], _AfterValidator(_require_unique)]" = _Field(
        default_factory=list,
    )


class ValidatedBytes(_ProtoModel):
    """
    ValidatedBytes exercises bytes length constraints.

    Attributes:
      token (bytes):
        Token must be at least 16 bytes.
      hash_ (bytes):
        Hash must be exactly 32 bytes.
      payload (bytes):
        Payload must be at most 1024 bytes.
    """

    model_config = _ConfigDict(
        populate_by_name=True,
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # Token must be at least 16 bytes.
    token: "bytes" = _Field(
        default=b"",
        description="Token must be at least 16 bytes.",
        min_length=16,
    )

    # Hash must be exactly 32 bytes.
    hash_: "bytes" = _Field(
        default=b"",
        description="Hash must be exactly 32 bytes.",
        alias="hash",
        min_length=32,
        max_length=32,
    )

    # Payload must be at most 1024 bytes.
    payload: "bytes" = _Field(
        default=b"",
        description="Payload must be at most 1024 bytes.",
        max_length=1024,
    )


class ValidatedStringContains(_ProtoModel):
    """
    ValidatedStringContains exercises the string.contains constraint.

    Attributes:
      topic (str):
        Topic must contain "protobuf".
      label (str):
        Label must start with "env-" and contain "prod".
        The contains conflicts with prefix so contains is dropped.
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    # Topic must contain "protobuf".
    topic: "str" = _Field(
        default="",
        description='Topic must contain "protobuf".',
        pattern="protobuf",
    )

    # Label must start with "env-" and contain "prod".
    # The contains conflicts with prefix so contains is dropped.
    label: "str" = _Field(
        default="",
        description='Label must start with "env-" and contain "prod".\nThe contains conflicts with prefix so contains is dropped.',
        pattern="^env-",
        # buf.validate: contains (not translated)
    )


class ValidatedRequired(_ProtoModel):
    """
    ValidatedRequired exercises required = true on proto3 optional scalar fields
    (where it strips | None) vs. message-typed and plain scalar fields (dropped).

    Attributes:
      required_name (str):
        required on proto3 optional scalar: | None stripped, field becomes required.
      required_score (int):
        required on proto3 optional scalar with an additional constraint.
      required_detail (ValidatedRequired.Detail | None):
        required on message-typed optional: not translated, emits dropped comment.
      plain_name (str):
        required on plain proto3 scalar: not translated, emits dropped comment.
    """

    model_config = _ConfigDict(
        ser_json_bytes="base64",
        val_json_bytes="base64",
        ser_json_inf_nan="strings",
    )

    class Detail(_ProtoModel):
        """
        Detail is a nested message used to test message-typed required handling.

        Attributes:
          value (str):
        """

        model_config = _ConfigDict(
            ser_json_bytes="base64",
            val_json_bytes="base64",
            ser_json_inf_nan="strings",
        )

        value: "str" = _Field(default="")

    # required on proto3 optional scalar: | None stripped, field becomes required.
    required_name: "str" = _Field(
        default=...,
        description="required on proto3 optional scalar: | None stripped, field becomes required.",
    )

    # required on proto3 optional scalar with an additional constraint.
    required_score: "int" = _Field(
        default=...,
        description="required on proto3 optional scalar with an additional constraint.",
        gt=0,
    )

    # required on message-typed optional: not translated, emits dropped comment.
    required_detail: "ValidatedRequired.Detail | None" = _Field(
        default=None,
        description="required on message-typed optional: not translated, emits dropped comment.",
        # buf.validate: required (not translated)
    )

    # required on plain proto3 scalar: not translated, emits dropped comment.
    plain_name: "str" = _Field(
        default="",
        description="required on plain proto3 scalar: not translated, emits dropped comment.",
        # buf.validate: required (not translated)
    )

# DO NOT EDIT. Generated by protoc-gen-pydantic.
import datetime as _datetime
import ipaddress as _ipaddress
import re as _re
import uuid as _uuid_lib
from typing import Annotated as _Annotated

from pydantic import AnyUrl as _AnyUrl
from pydantic import BeforeValidator as _BeforeValidator
from pydantic import PlainSerializer as _PlainSerializer
from pydantic import TypeAdapter as _TypeAdapter

_url_adapter = _TypeAdapter(_AnyUrl)


def _coerce_int(v):
    return int(v)


ProtoInt64 = _Annotated[
    int,
    _BeforeValidator(_coerce_int),
    _PlainSerializer(lambda v: str(v), return_type=str, when_used="json"),
]

ProtoUInt64 = _Annotated[
    int,
    _BeforeValidator(_coerce_int),
    _PlainSerializer(lambda v: str(v), return_type=str, when_used="json"),
]


def _parse_timestamp(v):
    if isinstance(v, str):
        return _datetime.datetime.fromisoformat(v.replace("Z", "+00:00"))
    if isinstance(v, _datetime.datetime):
        return v
    raise ValueError(f"Cannot parse timestamp from {type(v)}")


def _serialize_timestamp(v):
    if v.tzinfo is None:
        v = v.replace(tzinfo=_datetime.timezone.utc)
    s = v.strftime("%Y-%m-%dT%H:%M:%S")
    us = v.microsecond
    if us:
        s += f".{us:06d}".rstrip("0")
    return s + "Z"


ProtoTimestamp = _Annotated[
    _datetime.datetime,
    _BeforeValidator(_parse_timestamp),
    _PlainSerializer(_serialize_timestamp, return_type=str, when_used="json"),
]


def _parse_duration(v):
    if isinstance(v, str):
        m = _re.match(r"^(-?\d+(?:\.\d+)?)s$", v)
        if not m:
            raise ValueError(f"Invalid duration: {v}")
        return _datetime.timedelta(seconds=float(m.group(1)))
    if isinstance(v, _datetime.timedelta):
        return v
    raise ValueError(f"Cannot parse duration from {type(v)}")


def _serialize_duration(v):
    total = v.total_seconds()
    if total == int(total):
        return f"{int(total)}s"
    return f"{total}s"


ProtoDuration = _Annotated[
    _datetime.timedelta,
    _BeforeValidator(_parse_duration),
    _PlainSerializer(_serialize_duration, return_type=str, when_used="json"),
]


def _require_unique(v):
    if len(v) != len(set(v)):
        raise ValueError("list items must be unique")
    return v


def _make_in_validator(valid_values):
    def _validate(v):
        if v not in valid_values:
            raise ValueError(f"value must be one of {sorted(valid_values)}")
        return v

    return _validate


def _make_not_in_validator(excluded_values):
    def _validate(v):
        if v in excluded_values:
            raise ValueError(f"value must not be one of {sorted(excluded_values)}")
        return v

    return _validate


def _validate_email(v: str) -> str:
    if not v:
        return v
    from pydantic.networks import validate_email as _pydantic_validate_email

    _pydantic_validate_email(v)
    return v


def _validate_uri(v: str) -> str:
    if not v:
        return v
    _url_adapter.validate_python(v)
    return v


def _validate_ip(v: str) -> str:
    if not v:
        return v
    _ipaddress.ip_address(v)
    return v


def _validate_ipv4(v: str) -> str:
    if not v:
        return v
    _ipaddress.IPv4Address(v)
    return v


def _validate_ipv6(v: str) -> str:
    if not v:
        return v
    _ipaddress.IPv6Address(v)
    return v


def _validate_uuid(v: str) -> str:
    if not v:
        return v
    _uuid_lib.UUID(v)
    return v

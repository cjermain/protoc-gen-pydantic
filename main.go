package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

var (
	Version = "(unknown)"

	SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
	matchFirstCap     = regexp.MustCompile("([a-z0-9])([A-Z])")
	matchAllCap       = regexp.MustCompile("([A-Z])([A-Z][a-z])")

	tmpl *template.Template
)

func init() {
	tmpl = template.Must(template.New("pydantic").Parse(modelTemplate))
}

func main() {
	var flags flag.FlagSet
	preservingProtoFieldName := flags.Bool("preserving_proto_field_name", false, "")
	autoTrimEnumPrefix := flags.Bool("auto_trim_enum_prefix", true, "")
	useIntegersForEnums := flags.Bool("use_integers_for_enums", false, "")
	disableFieldDescription := flags.Bool("disable_field_description", false, "")
	useNoneUnionSyntaxInsteadOfOptional := flags.Bool("use_none_union_syntax_instead_of_optional", false, "")

	opts := protogen.Options{
		ParamFunc: flags.Set,
	}
	opts.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = SupportedFeatures

		e := NewGenerator(GeneratorConfig{
			PreservingProtoFieldName:            *preservingProtoFieldName,
			AutoTrimEnumPrefix:                  *autoTrimEnumPrefix,
			UseIntegersForEnums:                 *useIntegersForEnums,
			DisableFieldDescription:             *disableFieldDescription,
			UseNoneUnionSyntaxInsteadOfOptional: *useNoneUnionSyntaxInsteadOfOptional,
		})

		leafDirs := map[string]bool{}
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			e.reset()
			if err := e.processFile(f.Desc, f.Proto); err != nil {
				return fmt.Errorf("processing %s: %w", f.Desc.Path(), err)
			}

			filename := f.GeneratedFilenamePrefix + "_pydantic.py"
			g := gen.NewGeneratedFile(filename, f.GoImportPath)
			if err := e.Generate(g); err != nil {
				return fmt.Errorf("failed to write to %s: %w", filename, err)
			}

			leafDirs[filepath.Dir(f.GeneratedFilenamePrefix)] = true
		}

		for dir := range leafDirs {
			initPath := filepath.Join(dir, "__init__.py")
			g := gen.NewGeneratedFile(initPath, "")
			g.P("# Generated by protoc-gen-pydantic.")
		}

		return nil
	})
}

// Template for Pydantic model
const modelTemplate = `# DO NOT EDIT. Generated by protoc-gen-pydantic.
{{- $config := .Config -}}
{{- $hasEnumOptions := .HasEnumOptions -}}
{{- if .File.LeadingComments }}
"""
{{- range .File.LeadingComments }}
{{ . }}
{{- end }}
"""
{{- end }}
{{ if .StdImports._Enum }}
from enum import Enum as _Enum
{{- end }}
{{- if $hasEnumOptions }}
from dataclasses import dataclass as _dataclass
{{- end }}
{{- if or .StdImports._Any .StdImports._Optional }}
from typing import {{ if .StdImports._Any }}Any as _Any{{ if .StdImports._Optional }}, {{ end }}{{ end }}{{ if .StdImports._Optional }}Optional as _Optional{{ end }}
{{- end }}
{{- if .StdImports._BaseModel }}

from pydantic import BaseModel as _BaseModel{{ if .StdImports._ConfigDict }}, ConfigDict as _ConfigDict{{ end }}, Field as _Field
{{- end }}
{{- range .RelativeImports }}

{{ . }}
{{- end }}
{{- range .ExternalImports }}

{{ . }}
{{- end }}
{{- if $hasEnumOptions }}


@_dataclass(frozen=True)
class _EnumValueOptions:
    number: int
    deprecated: bool = False
    debug_redact: bool = False


class _ProtoEnum({{ if $config.UseIntegersForEnums }}int{{ else }}str{{ end }}, _Enum):
    _options_: _EnumValueOptions

    def __new__(cls, value: {{ if $config.UseIntegersForEnums }}int{{ else }}str{{ end }}, options: _EnumValueOptions | None = None):
        obj = {{ if $config.UseIntegersForEnums }}int{{ else }}str{{ end }}.__new__(cls, value)
        obj._value_ = value
        if options is not None:
            obj._options_ = options
        return obj

    @property
    def options(self) -> _EnumValueOptions:
        return self._options_
{{- end }}
{{- range .Enums }}


class {{ .Name }}({{ if .HasOptions }}_ProtoEnum{{ else }}{{ if $config.UseIntegersForEnums }}int{{ else }}str{{ end }}, _Enum{{ end }}):
    """
    {{- range .LeadingComments }}
    {{ . }}
    {{- end }}
    """
    {{- if .TrailingComments }}
    {{ range .TrailingComments }}
    # {{ . }}
    {{- end }}
    {{- end }}
    {{- range .Values }}
    {{ range .LeadingComments }}
    # {{ . }}
    {{- end }}
    {{- if .EnumHasOptions }}
    {{- if $config.UseIntegersForEnums }}
    {{ .Name }} = (
        {{ .Number }},
        _EnumValueOptions(number={{ .Number }}{{ if .Deprecated }}, deprecated=True{{ end }}{{ if .DebugRedact }}, debug_redact=True{{ end }}),
    )  # {{ .Name }}
    {{- else }}
    {{ .Name }} = (
        "{{ .Name }}",
        _EnumValueOptions(number={{ .Number }}{{ if .Deprecated }}, deprecated=True{{ end }}{{ if .DebugRedact }}, debug_redact=True{{ end }}),
    )  # {{ .Number }}
    {{- end }}
    {{- else }}
    {{- if $config.UseIntegersForEnums }}
    {{ .Name }} = {{ .Number }}  # {{ .Name }}
    {{- else }}
    {{ .Name }} = "{{ .Name }}"  # {{ .Number }}
    {{- end }}
    {{- end }}
    {{- range .TrailingComments }}
    # {{ . }}
    {{- end }}
    {{- end }}
{{- end }}
{{- range .Messages }}


class {{ .Name }}(_BaseModel):
    """
    {{- range .LeadingComments }}
    {{ . }}
    {{- end }}

    Attributes:
    {{- range .Fields }}
      {{ .Name }} ({{ .Type }}):
    {{- range .LeadingComments }}
        {{ . }}
    {{- end }}
    {{- end }}
    """
    {{- if .HasModelConfig }}

    model_config = _ConfigDict(populate_by_name=True)
    {{- end }}
    {{- range $i, $v := .TrailingComments }}{{ if eq $i 0 }}
{{ end }}
    # {{ $v }}
    {{- end }}
    {{ range .Fields }}
    {{- range .LeadingComments }}
    # {{ . }}
    {{- end }}
    {{- if and (not $config.DisableFieldDescription) (or (ne (len .LeadingComments) 0) (ne .OneOf nil)) }}
    {{ .Name }}: "{{ .Type }}" = _Field(
        {{ if or .Optional (ne .OneOf nil) }}None{{ else }}...{{ end }},
        description="""{{- range .LeadingComments -}}{{ . }}
{{ end }}{{ if ne .OneOf nil }}
Only one of the fields can be specified with: {{ .OneOf.FieldNames }} (oneof {{ .OneOf.Name }}){{ end }}""",
    {{- if .Alias }}
        alias="{{ .Alias }}",
    {{- end }}
    )
    {{- else }}
    {{ .Name }}: "{{ .Type }}" = _Field({{ if or .Optional (ne .OneOf nil) }}None{{ else }}...{{ end }}{{ if .Alias }}, alias="{{ .Alias }}"{{ end }})
    {{- end }}
    {{- range .TrailingComments }}
    # {{ . }}
    {{- end }}
    {{ end }}
    {{- if eq (len .Fields) 0 }}
    pass
    {{- end }}
{{- end }}
{{- range .File.TrailingComments }}
# {{ . }}
{{- end }}
`

// reservedNames is the set of names that must not be used as Pydantic field
// names. Fields with these names are renamed with a trailing underscore and
// given an alias to preserve the original proto field name.
var reservedNames = map[string]bool{
	// Python builtins (shadow type annotations)
	"int": true, "float": true, "bool": true, "str": true, "bytes": true,
	"list": true, "dict": true, "set": true, "tuple": true, "type": true,
	"object": true, "range": true, "map": true, "filter": true,
	"id": true, "hash": true, "len": true, "max": true, "min": true,
	"sum": true, "abs": true, "round": true, "complex": true,
	"frozenset": true, "memoryview": true, "bytearray": true,
	"property": true, "classmethod": true, "staticmethod": true, "super": true,
	// Python keywords (cause SyntaxError if used as identifiers)
	"False": true, "None": true, "True": true,
	"and": true, "as": true, "assert": true, "async": true, "await": true,
	"break": true, "class": true, "continue": true, "def": true, "del": true,
	"elif": true, "else": true, "except": true, "finally": true, "for": true,
	"from": true, "global": true, "if": true, "import": true, "in": true,
	"is": true, "lambda": true, "nonlocal": true, "not": true, "or": true,
	"pass": true, "raise": true, "return": true, "try": true, "while": true,
	"with": true, "yield": true,
	// Pydantic BaseModel attributes (shadow model internals)
	"model_config": true, "model_fields": true, "model_computed_fields": true,
	"model_extra": true, "model_fields_set": true,
	"model_construct": true, "model_copy": true,
	"model_dump": true, "model_dump_json": true,
	"model_json_schema": true, "model_parametrized_name": true,
	"model_post_init": true, "model_rebuild": true,
	"model_validate": true, "model_validate_json": true,
	"model_validate_strings": true,
}

// wellKnownTypes maps protobuf well-known type full names to native Python types.
type wktMapping struct {
	pythonType string
	importLine string // added to external imports if non-empty
}

var wellKnownTypes = map[string]wktMapping{
	"google.protobuf.Timestamp":   {pythonType: "datetime.datetime", importLine: "import datetime"},
	"google.protobuf.Duration":    {pythonType: "datetime.timedelta", importLine: "import datetime"},
	"google.protobuf.Struct":      {pythonType: "dict[str, _Any]"},
	"google.protobuf.Value":       {pythonType: "_Any"},
	"google.protobuf.ListValue":   {pythonType: "list[_Any]"},
	"google.protobuf.Empty":       {pythonType: "None"},
	"google.protobuf.FieldMask":   {pythonType: "list[str]"},
	"google.protobuf.Any":         {pythonType: "_Any"},
	"google.protobuf.BoolValue":   {pythonType: "bool"},
	"google.protobuf.Int32Value":  {pythonType: "int"},
	"google.protobuf.Int64Value":  {pythonType: "int"},
	"google.protobuf.UInt32Value": {pythonType: "int"},
	"google.protobuf.UInt64Value": {pythonType: "int"},
	"google.protobuf.FloatValue":  {pythonType: "float"},
	"google.protobuf.DoubleValue": {pythonType: "float"},
	"google.protobuf.StringValue": {pythonType: "str"},
	"google.protobuf.BytesValue":  {pythonType: "bytes"},
}

type EnumValue struct {
	Name             string
	Number           int32
	Deprecated       bool
	DebugRedact      bool
	EnumHasOptions   bool // true if parent enum has any value options
	LeadingComments  []string
	TrailingComments []string
}

type Enum struct {
	Name             string
	Values           []EnumValue
	LeadingComments  []string
	TrailingComments []string
}

func (e Enum) HasOptions() bool {
	for _, v := range e.Values {
		if v.Deprecated || v.DebugRedact {
			return true
		}
	}
	return false
}

type Field struct {
	Name             string
	Alias            string // non-empty when Name was renamed to avoid shadowing Python builtins
	Type             string
	Optional         bool
	OneOf            *OneOf
	LeadingComments  []string
	TrailingComments []string
}

type OneOf struct {
	Name       string
	FieldNames []string
}

type Message struct {
	Name             string
	Fields           []Field
	LeadingComments  []string
	TrailingComments []string
}

func (m Message) TopoKey() string {
	return m.Name
}

func (m Message) HasAlias() bool {
	for _, f := range m.Fields {
		if f.Alias != "" {
			return true
		}
	}
	return false
}

func (m Message) HasModelConfig() bool {
	return m.HasAlias()
}

type File struct {
	LeadingComments  []string
	TrailingComments []string
}

type generator struct {
	file            File
	enums           []Enum
	messages        []Message
	externalImports []string
	relativeImports []string
	stdImports      map[string]bool

	config GeneratorConfig
}

type GeneratorConfig struct {
	PreservingProtoFieldName            bool
	AutoTrimEnumPrefix                  bool
	UseIntegersForEnums                 bool
	DisableFieldDescription             bool
	UseNoneUnionSyntaxInsteadOfOptional bool
}

func NewGenerator(c GeneratorConfig) *generator {
	return &generator{
		config: c,
	}
}

func (e *generator) reset() {
	e.file = File{}
	e.enums = nil
	e.messages = nil
	e.externalImports = nil
	e.relativeImports = nil
	e.stdImports = map[string]bool{}
}

func (e *generator) hasEnumOptions() bool {
	for _, enum := range e.enums {
		if enum.HasOptions() {
			return true
		}
	}
	return false
}

func (e *generator) addStdImport(name string) {
	e.stdImports[name] = true
}

func (e *generator) Generate(w io.Writer) error {
	var buf bytes.Buffer
	hasEnumOptions := e.hasEnumOptions()
	err := tmpl.Execute(&buf, struct {
		File            File
		Enums           []Enum
		Messages        []Message
		ExternalImports []string
		RelativeImports []string
		Config          GeneratorConfig
		StdImports      map[string]bool
		HasEnumOptions  bool
	}{
		e.file,
		e.enums,
		e.messages,
		e.externalImports,
		e.relativeImports,
		e.config,
		e.stdImports,
		hasEnumOptions,
	})
	if err != nil {
		return err
	}

	// Post-process: strip trailing whitespace from each line.
	output := buf.String()
	lines := strings.Split(output, "\n")
	for i, line := range lines {
		lines[i] = strings.TrimRight(line, " \t")
	}
	output = strings.Join(lines, "\n")

	// Collapse 3+ consecutive blank lines to exactly 2.
	for strings.Contains(output, "\n\n\n\n") {
		output = strings.ReplaceAll(output, "\n\n\n\n", "\n\n\n")
	}

	// Ensure file ends with exactly one newline.
	output = strings.TrimRight(output, "\n") + "\n"

	_, err = io.WriteString(w, output)
	return err
}

func (e *generator) processFile(file protoreflect.FileDescriptor, fdp *descriptorpb.FileDescriptorProto) error {
	def := File{}
	sourceCodeInfo := fdp.GetSourceCodeInfo()
	path := []int32{12}
	def.LeadingComments, def.TrailingComments = extractComments(sourceCodeInfo, path)
	e.file = def
	for i := range file.Enums().Len() {
		ed := file.Enums().Get(i)
		ep := fdp.GetEnumType()[i]
		path := []int32{5, int32(i)}
		if err := e.processEnum(ed, ep, sourceCodeInfo, path); err != nil {
			return err
		}
	}
	for i := range file.Messages().Len() {
		msgd := file.Messages().Get(i)
		msgp := fdp.GetMessageType()[i]
		path := []int32{4, int32(i)}
		if err := e.processMessage(msgd, msgp, sourceCodeInfo, path); err != nil {
			return err
		}
	}
	return nil
}

func (e *generator) processEnum(
	enum protoreflect.EnumDescriptor,
	enumProto *descriptorpb.EnumDescriptorProto,
	sourceCodeInfo *descriptorpb.SourceCodeInfo,
	path []int32,
) error {
	def := Enum{
		Name:   resolveName(enum),
		Values: []EnumValue{},
	}
	def.LeadingComments, def.TrailingComments = extractComments(sourceCodeInfo, path)

	prefix := camelToSnakeCase(string(enum.Name())) + "_"
	for i := range enum.Values().Len() {
		v := enum.Values().Get(i)
		valueName := string(v.Name())
		if e.config.AutoTrimEnumPrefix {
			valueName = strings.TrimPrefix(valueName, prefix)
		}
		fieldPath := append(append([]int32{}, path...), 2, int32(i))
		leadingComments, trailingComments := extractComments(sourceCodeInfo, fieldPath)

		var deprecated, debugRedact bool
		if vp := enumProto.GetValue()[i]; vp.GetOptions() != nil {
			deprecated = vp.GetOptions().GetDeprecated()
			debugRedact = vp.GetOptions().GetDebugRedact()
		}

		def.Values = append(def.Values, EnumValue{
			Name:             valueName,
			Number:           int32(v.Number()),
			Deprecated:       deprecated,
			DebugRedact:      debugRedact,
			LeadingComments:  leadingComments,
			TrailingComments: trailingComments,
		})
	}

	// If the enum has any value options, mark all values so the template
	// can emit tuple syntax for the entire enum.
	if def.HasOptions() {
		for i := range def.Values {
			def.Values[i].EnumHasOptions = true
		}
	}

	e.addStdImport("_Enum")
	e.enums = append(e.enums, def)
	return nil
}

func (e *generator) processMessage(
	msg protoreflect.MessageDescriptor,
	msgProto *descriptorpb.DescriptorProto,
	sourceCodeInfo *descriptorpb.SourceCodeInfo,
	path []int32,
) error {
	if msg.IsMapEntry() {
		return nil
	}

	// NOTE: Process nested enums and messages before the fields.
	for i, nest := range iter(msg.Enums()) {
		nestPath := append(append([]int32{}, path...), 4, int32(i))
		if err := e.processEnum(nest, msgProto.GetEnumType()[i], sourceCodeInfo, nestPath); err != nil {
			return fmt.Errorf("enum %s: %w", string(nest.Name()), err)
		}
	}

	for i, nest := range iter(msg.Messages()) {
		nestPath := append(append([]int32{}, path...), 3, int32(i))
		if err := e.processMessage(nest, msgProto.GetNestedType()[i], sourceCodeInfo, nestPath); err != nil {
			return fmt.Errorf("message %s: %w", string(nest.Name()), err)
		}
	}

	def := Message{
		Name:   resolveName(msg),
		Fields: []Field{},
	}
	def.LeadingComments, def.TrailingComments = extractComments(sourceCodeInfo, path)

	for i, field := range iter(msg.Fields()) {
		typ, err := e.resolveType(def.Name, field)
		if err != nil {
			return fmt.Errorf("field %s.%s: %w", def.Name, field.Name(), err)
		}
		fieldPath := append(append([]int32{}, path...), 2, int32(i))
		var oneOf *OneOf
		if oo := field.ContainingOneof(); !field.HasOptionalKeyword() && oo != nil {
			var fieldNames []string
			for _, f := range iter(oo.Fields()) {
				fieldNames = append(fieldNames, string(f.Name()))
			}
			oneOf = &OneOf{
				Name:       string(oo.Name()),
				FieldNames: fieldNames,
			}
		}
		name := field.JSONName()
		if e.config.PreservingProtoFieldName {
			name = string(field.Name())
		}
		var alias string
		if reservedNames[name] {
			alias = name
			name = name + "_"
		}
		f := Field{
			Name:     name,
			Alias:    alias,
			Type:     typ,
			Optional: field.HasOptionalKeyword(),
			OneOf:    oneOf,
			// Description: resolveFieldDescription(field),
		}
		f.LeadingComments, f.TrailingComments = extractComments(sourceCodeInfo, fieldPath)
		def.Fields = append(def.Fields, f)
	}

	e.addStdImport("_BaseModel")
	e.addStdImport("_Field")
	if def.HasModelConfig() {
		e.addStdImport("_ConfigDict")
	}
	e.messages = append(e.messages, def)
	return nil
}

func (e *generator) addExternalImport(importLine string) {
	for _, imp := range e.externalImports {
		if imp == importLine {
			return
		}
	}
	e.externalImports = append(e.externalImports, importLine)
}

func (e *generator) addRelativeImport(importLine string) {
	for _, imp := range e.relativeImports {
		if imp == importLine {
			return
		}
	}
	e.relativeImports = append(e.relativeImports, importLine)
}

// addCrossFileImport adds the appropriate import statement when a type from
// targetFile is referenced from sourceFile. No import is added for same-file
// references. Same-package cross-file uses relative imports; cross-package
// uses absolute imports.
func (e *generator) addCrossFileImport(sourceFile, targetFile protoreflect.FileDescriptor, typeName string) error {
	if sourceFile.Path() == targetFile.Path() {
		return nil
	}
	targetPath := string(targetFile.Path())
	moduleName := strings.TrimSuffix(filepath.Base(targetPath), ".proto") + "_pydantic"
	if string(sourceFile.Package()) == string(targetFile.Package()) {
		e.addRelativeImport(fmt.Sprintf("from .%s import %s", moduleName, typeName))
	} else {
		// Use the file path (not package name) to derive the Python module path.
		dir := filepath.Dir(targetPath)
		pyPkg := strings.ReplaceAll(dir, string(filepath.Separator), ".")
		e.addExternalImport(fmt.Sprintf("from %s.%s import %s", pyPkg, moduleName, typeName))
	}
	return nil
}

func (e *generator) resolveBaseType(referer string, field protoreflect.FieldDescriptor) (string, error) {
	switch field.Kind() {
	case
		protoreflect.Int32Kind,
		protoreflect.Int64Kind,
		protoreflect.Uint32Kind,
		protoreflect.Uint64Kind,
		protoreflect.Fixed32Kind,
		protoreflect.Fixed64Kind,
		protoreflect.Sint32Kind,
		protoreflect.Sint64Kind,
		protoreflect.Sfixed32Kind,
		protoreflect.Sfixed64Kind:
		return "int", nil
	case protoreflect.BoolKind:
		return "bool", nil
	case protoreflect.DoubleKind,
		protoreflect.FloatKind:
		return "float", nil
	case protoreflect.StringKind:
		return "str", nil
	case protoreflect.BytesKind:
		return "bytes", nil
	case protoreflect.MessageKind:
	case protoreflect.EnumKind:
		enum := field.Enum()
		typeName := resolveName(enum)
		if err := e.addCrossFileImport(field.ParentFile(), enum.ParentFile(), typeName); err != nil {
			return "", err
		}
		return typeName, nil
	case protoreflect.GroupKind:
		return "", fmt.Errorf("unsupported type: %s", field.Kind())
	}

	// Handle message types.
	msg := field.Message()

	// Well-known type mappings to native Python types.
	if wkt, ok := wellKnownTypes[string(msg.FullName())]; ok {
		if wkt.importLine != "" {
			e.addExternalImport(wkt.importLine)
		}
		if strings.Contains(wkt.pythonType, "_Any") {
			e.addStdImport("_Any")
		}
		return wkt.pythonType, nil
	}

	if field.IsMap() {
		key, err := e.resolveType(referer, field.MapKey())
		if err != nil {
			return "", err
		}
		val, err := e.resolveType(referer, field.MapValue())
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("dict[%s, %s]", key, val), nil
	}

	typeName := resolveName(msg)
	if err := e.addCrossFileImport(field.ParentFile(), msg.ParentFile(), typeName); err != nil {
		return "", err
	}
	return typeName, nil
}

func (e *generator) resolveType(referer string, field protoreflect.FieldDescriptor) (string, error) {
	typ, err := e.resolveBaseType(referer, field)
	if err != nil {
		return "", err
	}

	if field.IsList() {
		return fmt.Sprintf("list[%s]", typ), nil
	}

	if field.HasOptionalKeyword() || field.ContainingOneof() != nil {
		if e.config.UseNoneUnionSyntaxInsteadOfOptional {
			return fmt.Sprintf("%s | None", typ), nil
		}
		e.addStdImport("_Optional")
		return fmt.Sprintf("_Optional[%s]", typ), nil
	}

	return typ, nil
}

func equalPath(a, b []int32) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func resolveName(d protoreflect.Descriptor) string {
	prefix := string(d.ParentFile().FullName()) + "."
	name := string(d.FullName())
	name = strings.TrimPrefix(name, prefix)
	name = strings.ReplaceAll(name, ".", "_")
	return string(name)
}

func extractComments(sourceCodeInfo *descriptorpb.SourceCodeInfo, path []int32) (leading []string, trailing []string) {
	if sourceCodeInfo != nil {
		for _, location := range sourceCodeInfo.Location {
			if equalPath(location.Path, path) {
				leading = extractCommentLines(location.GetLeadingComments())
				trailing = extractCommentLines(location.GetTrailingComments())
				break
			}
		}
	}
	return
}

func extractCommentLines(comment string) []string {
	if comment == "" {
		return nil
	}
	comment = strings.TrimSpace(comment)
	comments := strings.Split(comment, "\n")
	for i := range comments {
		comments[i] = strings.TrimSpace(comments[i])
	}
	return comments
}

func iter[T any](d interface {
	Len() int
	Get(int) T
},
) func(func(k int, v T) bool) {
	return func(yield func(k int, v T) bool) {
		for i := range d.Len() {
			yield(i, d.Get(i))
		}
	}
}

func camelToSnakeCase(str string) string {
	snake := matchFirstCap.ReplaceAllString(str, "${1}_${2}")
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
	return strings.ToUpper(snake)
}
